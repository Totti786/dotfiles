#!/usr/bin/env bash

# Define cache and file paths
data_dir="$HOME/.local/share/rofi-media"
shortcuts="$HOME/.local/share/applications/media"
watchlater_dir="$data_dir/watch_later"
media_history="$data_dir/media_history.txt"
config_file="$data_dir/conf.sh"
fallback_poster="$data_dir/cover.jpg"  # Define the path to your fallback poster image

# Create necessary directories if they don't exist
mkdir -p "$shortcuts"
mkdir -p "$watchlater_dir"

[[ -f "$config_file" ]] && . "${config_file}" || echo  "# rofi-media config file" >> "${config_file}"

[[ -z "$anime_directory" ]] && anime_directory="$HOME/Videos/Anime"
[[ -z "$movies_directory" ]] && movies_directory="$HOME/Videos/Movies"
[[ -z "$shows_directory" ]] && shows_directory="$HOME/Videos/Shows"
[[ -z "$speed" ]] && speed="1.0"

if [[ ! -f "$fallback_poster" ]]; then
	eval $(xrdb -query | awk '/color0/{print "color0="$NF} /color7/{print "color7="$NF}')
	magick -size 300x445 xc:"$color0" "$fallback_poster"
	magick "$fallback_poster" -gravity center -fill "$color7" \
	-font /usr/share/fonts/TTF/JetBrainsMonoNerdFont-Regular.ttf \
	-pointsize 90 -annotate 0 "ó°¿Ž" "$fallback_poster"
fi

get_poster(){
	if [ -z "$1" ]; then
		echo "Usage: $0 <title> <year (optional)> <type>"
		exit 1
	fi

	type="$1"
	title="$2"
	year="$3"
	
	cover_dir="$data_dir/$type"
	mkdir -p "$cover_dir"
	
	# Prepare the title argument for the API request
	encoded_title=$(echo "$title" | tr ' ' '+')
	
	if [ "$type" == "anime" ]; then
		# Fetch anime data from Jikan API
		response=$(curl -s "https://api.jikan.moe/v4/anime?q=$encoded_title&season=$year")
		poster_url=$(echo "$response" | jq -r '.data[0].images.jpg.large_image_url')
	else
		API_KEY="497fd34e"
		# Fetch movie/show data from OMDB API
		response=$(curl -s "http://www.omdbapi.com/?t=$encoded_title&year=$year&apikey=$API_KEY")
		poster_url=$(echo "$response" | jq -r '.Poster')
	fi

	# Check for errors
	error_message=$(echo "$response" | jq -r '.Error')
	if [ "$error_message" != "null" ]; then
		echo "Error: $error_message"
		poster_url="N/A"
	fi

	if [ "$poster_url" == "N/A" ]; then
		echo "No poster available for '$title', using fallback image."
		cp "$fallback_poster" "$cover_dir/$title.jpg"
	else
		wget -q "$poster_url" -O "$cover_dir/$title.jpg"
		echo "Poster downloaded as '$cover_dir/$title.jpg'"
	fi
}

process_media(){
	media_type="$1"
	
	case "$media_type" in
		"movies")
			media_directory="$movies_directory"
			exec_command="mpv --speed=$speed --write-filename-in-watch-later-config --save-position-on-quit"
			# Find media files directly
			readarray -t lines < <(find -L "$media_directory" -type f \( -iname "*.mp4" -o -iname "*.mkv" \))
			;;
		"shows" | "anime")
			media_directory="$([ "$media_type" = "shows" ] && echo "$shows_directory" || echo "$anime_directory")"
			exec_command="$0 --episode"

			# Find directories containing media files
			readarray -t lines < <(find "$media_directory" -mindepth 1 -maxdepth 1 \( -type d -o -type l \) -print0 | while IFS= read -r -d '' dir; do
				if find -L "$dir" -type f \( -iname "*.mp4" -o -iname "*.mkv" \) -print -quit | grep -q .; then
					echo "$dir"
				fi
			done)
			;;
		*)
			echo "Invalid media type specified."
			exit 1
			;;
	esac

	if [ ${#lines[@]} -eq 0 ]; then
		notify-send -r 12 -u low -a rofi-media "rofi-media" "No files were found in $media_directory"
		return
	elif [ ${#lines[@]} -gt "$( ls -A "$data_dir/$media_type" | wc -l)" ]; then
		notify-send -r 12 -u low -a rofi-media "rofi-media" "Getting posters..."
	fi

	for line in "${lines[@]}"; do
		# Extract the name of the file from the path
		name="${line##*/}"
		# Remove the file extension from the name
		name="${name%.*}"

		# Extract the year and remove everything after it
		if [[ "$name" =~ ([1][9][0-9]{2}|20[0-9]{2}) ]]; then
			# Get the year if present and strip the title of extra info
			year="${BASH_REMATCH[1]}"
			title=$(echo "$name" | sed -e "s/$year.*//" -e 's/\[[^]]*\]//g' -e 's/([^)]*)//g' -e 's/{[^}]*}//g' -e 's/[._()-]/ /g' -e 's/[[:space:]]\+/ /g' -e 's/^[ \t]*//;s/[ \t]*$//' -e 's/ S[0-9][0-9]*.*//')

			# Check if title is empty or only contains the year
			if [[ -z "$title" || "$title" =~ ^[[:space:]]*$ ]]; then
				# If title is empty or only contains spaces, set title to the year itself
				title="$year"
			fi
		else
			# Remove trailing spaces
			title=$(echo "$name" | sed -e 's/\[[^]]*\]//g' -e 's/([^)]*)//g' -e 's/{[^}]*}//g' -e 's/[._()-]/ /g' -e 's/[[:space:]]\+/ /g' -e 's/^[ \t]*//;s/[ \t]*$//' -e 's/ S[0-9][0-9]*.*//')
			year=""
		fi

		# Create a list of used posters
		used_images+=("$data_dir/$media_type/$title.jpg")

		# Check if the poster file is missing and download it
		if ! [[ -f "$data_dir/$media_type/$title.jpg" ]]; then
			get_poster "$media_type" "$title" "$year"
		fi

		menu_entry="$shortcuts/$name.desktop"

		if [[ ! -f "$menu_entry" ]]; then
			cat > "$menu_entry" <<- EOF
			[Desktop Entry]
			Name=$title
			Exec=$exec_command "$line"
			Icon=$data_dir/$media_type/$title.jpg
			Type=Application
			Categories=${media_type^};
			EOF
		fi
	done

	# Delete unused posters
	for cached_image in "$data_dir/$media_type"/*.jpg; do
		if [[ ! " ${used_images[@]} " =~ " ${cached_image} " ]]; then
			rm "$cached_image"
		fi
	done

	rofi -show drun -drun-categories "${media_type^}" -theme rofi-media
}

prompt_menu(){
	echo -e "$1" | rofi -dmenu -mesg "$2" -theme-str "#mainbox { children: [ message, listview ]; } #textbox { padding: 24px; }"
}

play_media() {
	local file_path="$1"
	local start_position="$2"

	[[ -z "$start_position" ]] && start_position="0"
	get_duration &
	
	mpv --speed="$speed" --keep-open=always --watch-later-dir="$watchlater_dir" \
		--write-filename-in-watch-later-config --save-position-on-quit \
		--start="$start_position" "$file_path" >/dev/null 2>&1
}

get_duration(){
	sleep 2
	duration="$([[ "$(pgrep mpv)" ]]  && echo '{"command": ["get_property", "duration"]}' | socat - /tmp/mpvsocket 2> /dev/null | awk -F'"data":|,' '{print $2}')"
	[[ -n "$duration" ]] && printf "%.0f" "$duration" > "$watchlater_dir"/duration
}

save_history(){
	local name="${1##*/}"
	local name="${name%.*}"
	local duration="$(cat $watchlater_dir/duration 2> /dev/null)"

	file="$(grep -hB1 "start=" $watchlater_dir/* 2>/dev/null | grep -A2 "$name")"

	position="$(echo $file | awk -F= '/start/ {print int($2)}')"
	path="$(echo $file | awk -F' start=' '/^# / {print substr($1, 3)}')"

	[[ -n "$duration" ]] && local progress=$(($position * 100 / $duration))

	if grep -qw "$name" "$media_history"; then
		sed -i "/$name/d" "$media_history"
	fi

	printf "%s\t%s\t%s\t%s\n" "$name" "$position" "$path" "$progress" >> "$media_history"

	rm "$watchlater_dir"/*
}

check_history(){
	local name="${1##*/}"

	position="$(grep -hw "$name" $media_history | awk -F'\t' '{print $2}')"
	path="$(grep -hw "$name" $media_history | awk -F'\t' '{print $3}')"
	progress="$(grep -hw "$name" $media_history | awk -F'\t' '{print $4}')"
	dir="${path%/*}"
	episode=$(echo "${path##*/}" | sed -n -e 's/.*[eE]\([0-9]\{2\}\).*/\1/p' -e 's/.*\b\([0-9]\{2\}\)\b.*/\1/p' | head -n1)
}

prompt(){
	local show="$1"
	check_history "$show"

	local episode_number="$episode"
	local selected_directory="$dir"

	# Check for the next episode in the current season
	next_episode_number=$(printf '%02d' $((10#$episode_number + 1)))
	next_episode_file=$(ls -p "$selected_directory" | grep -v / | sort | grep -E "S[0-9]+E$next_episode_number| - $next_episode_number - | - $next_episode_number\..*|[_\.x-]$next_episode_number\.")

	if [[ -n "$next_episode_file" ]]; then
		
		
		if [[ "$progress" -ge 90 ]]; then 
			options="$(prompt_menu "Next\nReplay\nSelect\nExit" "Select an option:")"
		else
			options="$(prompt_menu "Next\nResume\nReplay\nSelect\nExit" "Select an option:")"
		fi

		case "$options" in
		"Next")
			play_media "$selected_directory/$next_episode_file"
			save_history "$show"
			episode_number=$(($episode_number + 1))
			prompt "$show"
			;; 
		"Resume")
			play_media "$path" "$position"
			save_history "$show"
			prompt "$show"
			;;
		"Replay")
			play_media "$path"
			save_history "$show"
			prompt "$show"
			;;
		"Select")
			select_episode "$show"
			;;
		"Exit")
			exit 0
			::
		esac

	else
		# Check if there is another season available
		parent_directory="${selected_directory%/*}"
		current_season="${selected_directory##*/}"
		
		next_season_dir=$(ls -v "$parent_directory" | grep -A1 "$current_season" | tail -n1)
	
		if [[ -n "$next_season_dir" && "$next_season_dir" != "$current_season" && "$parent_directory" != "$shows_directory" && "$parent_directory" != "$anime_directory" ]]; then
			next_season_dir="$parent_directory/$next_season_dir"
			binge_next_season="$(prompt_menu "Yes\nNo" "Next season available. Play next season?")"
			if [[ "$binge_next_season" == "Yes" ]]; then
				first_episode_file=$(ls -p "$next_season_dir" | grep -v / | sort | grep -E '\.mp4$|\.mkv$' | head -n1)
				if [[ -n "$first_episode_file" ]]; then
					play_media "$next_season_dir/$first_episode_file"
					save_history "$show"
					prompt "$show"
				fi
			fi
		fi
	fi
}

play_history(){
	local show="$1"
	check_history "$show"

	if [[ "$progress" -ge 90 ]]; then

		local episode_number="$episode"
		local selected_directory="$dir"

		# Check for the next episode in the current season
		next_episode_number=$(printf '%02d' $((10#$episode_number + 1)))
		next_episode_file=$(ls -p "$selected_directory" | grep -v / | sort | grep -E "S[0-9]+E$next_episode_number| - $next_episode_number - | - $next_episode_number\..*|[_\.x-]$next_episode_number\.")

		if [[ -n "$next_episode_file" ]]; then
			path="$selected_directory/$next_episode_file"
			position=""
		else 
			path=""
		fi		
	fi

	[[ -n "$path" ]] && history=$(prompt_menu "Yes\nNo" "Resume from where you left off?")

	if [[ "$history" == "Yes" ]]; then
		play_media "$path" "$position"
		save_history "$show"
		[[ -d "$show" ]] &&  prompt "$show"
		exit 0
	else
		if [[ -f "$show" ]]; then
			play_media "$show"
			save_history "$show"
		else
			select_episode "$show"
		fi
	fi
}

select_episode(){
	local show="$1"	

	# Check if there are multiple season directories, only if there are no video files in the directory
	[[ -z "$(ls -p "$show" | grep -v / | grep -E '\.mp4$|\.mkv$')" ]] && season_dirs="$(ls -v "$show")"

	if [[ -n "$season_dirs" ]]; then
	  season=$(prompt_menu "$(echo "$season_dirs" | sed -E '
		# Detect and format "Season X: Part Y" (e.g., S03P01 -> Season 3: Part 1)
		s/.*S0?([1-9][0-9]*)P0?([1-9][0-9]*).*/Season \1: Part \2/; t;
		# Detect and format "Season X Part Y" (e.g., Season 3 Part 1 -> Season 3: Part 1)
		s/.*Season ([0-9]+) Part ([0-9]+).*/Season \1: Part \2/; t;
		# Handle regular "Season X" without part (e.g., S01 -> Season 1)
		s/.*S0?([1-9][0-9]*).*/Season \1/; t;
		# Handle "Season X" in plain text (e.g., "Season 3")
		s/.*Season ([0-9]+).*/Season \1/; t;
		# If none of the above patterns match, just keep the name unchanged
		s!.*/!!')" \
		"Select the season:")

		[[ -z "$season" ]] && exit 1

	    season_number=$(echo "$season" | grep -oP '(?<=Season\s)\d+')
	    part_number=$(echo "$season" | grep -oP '(?<=Part\s)\d+')

		if [[ -n "$part_number" ]]; then
			season_pattern="S0?$season_number+P0?$part_number+|S$season_number+P$part_number+"
		else
			season_pattern="(S0?$season_number|Season[[:space:]]*$season_number|^0?$season_number$)"
		fi

		[[ -n "$season_number" ]] && season=$(ls -v "$show" | grep -E -i "$season_pattern" | head -n 1)
		selected_directory="$show/$season"
	else
		selected_directory="$show"
	fi

	# Extract episode numbers and titles, and format the selection
	  selection=$(ls -p "$selected_directory" | grep -v / | grep -E '\.mp4$|\.mkv$' | sort | sed -E '
		s/\[.*\] .* - S[0-9]+E([0-9]+).*$/Episode \1/; t;
		# Handle standard episode formats with season and episode numbers
		s/.*S[0-9]+[Eex]([0-9]+)[^A-Za-z0-9]*([^0-9]+\S[^0-9]+?)[. ]+[^.]+$/Episode \1: \2/; t;
		s/.*S[0-9]+[Eex]([0-9]+)[^A-Za-z0-9]*([^0-9]+\S[^0-9]+?)[. ]+.*$/Episode \1: \2/; t;
		s/.*S[0-9]+[Eex]([0-9]+).*$/Episode \1/; t;
		# Match complex titles after a number if present, or just extract the title after the last dash
		s/.* - ([0-9]+[^0-9a-zA-Z]?) - ([^0-9]+?)\..*$/Episode \1: \2/; t;
		s/.* - ([^0-9]+?) - ([^0-9]+?)\..*$/\2/; t;
		s/.* - ([0-9]+[^0-9a-zA-Z]?)\..*$/Episode \1/; t;
		s/.* - Episode ([0-9]+) - ([^0-9]+?)\..*$/Episode \1: \2/; t;
		s/.* - Episode ([0-9]+)\..*$/Episode \1/; t;
		s/.*S[0-9]+E([0-9]+)\..*$/Episode \1/; t;
		# Handle cases where title is complex and episode number is not in the format
		s/.* - ([^-]+)\..*$/\1/; t;
		s/.* - ([^-]+)\..*$/\1/' | sed -E 's/\./ /g' \
		| rofi -sort -dmenu -p "Episode: " -mesg "Select the episode:")

	# Map the selected "Episode X: Title" or title without episode number back to the corresponding file name
	if [[ -n "$selection" ]]; then
		# Extract episode number if available
		episode_number=$(echo "$selection" | grep -o '[0-9]\+[^: ]*')

		# Extract title if it's prefixed with "Episode X:"
		episode_title=$(echo "$selection" | sed -E 's/^Episode [0-9]+[^ ]*: (.+)/\1/; t; s/^Episode [0-9]+[^ ]*//; t')  

		if [[ -n "$episode_title" ]] && ! [[ $selection =~ "Ep" ]]; then
			# Handle patterns with no episode number, matching by title
			episode_file=$(ls -p "$selected_directory" | grep -i "$episode_title" | grep -E '\.mp4$|\.mkv$')
		else
			# Handle both patterns with episode number
			episode_file=$(ls -p "$selected_directory" | grep -E "S[0-9]+E$episode_number| - Episode $episode_number - .*| - Episode $episode_number\..*| - $episode_number - .*| - $episode_number\..*" | grep -E '\.mp4$|\.mkv$')
		fi

		if [[ -n "$episode_file" ]]; then
			play_media "$selected_directory/$episode_file"
			save_history "$show"
			prompt "$show"
		fi
	fi
}

case "$1" in
	--movies|--shows|--anime)
		process_media "${1#--}" && rm -r "$shortcuts"
		;;
	--episode)
		play_history "$2"
		;;
	--clear)
		rm "$media_history"
		;;
	*)
		echo "Invalid option. Use --movies, --shows, --anime, or --episode."
		;;
esac
