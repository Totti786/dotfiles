#!/usr/bin/env bash

# Define cache and file paths
movies_directory="$HOME/Videos/Movies"
shows_directory="$HOME/Videos/Shows"
anime_directory="$HOME/Videos/Anime"
cached="$HOME/.cache/rofi-media"
shortcuts="$HOME/.local/share/applications/media"
watchlater_dir="$cached/watch_later"
fallback_poster="$cached/cover.jpg"  # Define the path to your fallback poster image

# Create necessary directories if they don't exist
mkdir -p "$shortcuts"
mkdir -p "$cached"
mkdir -p "$watchlater_dir"

if [[ ! -f "$fallback_poster" ]]; then
    eval $(xrdb -query | awk '/color0/{print "color0="$NF} /color7/{print "color7="$NF}')
    magick -size 300x445 xc:"$color0" "$fallback_poster"
    magick "$fallback_poster" -gravity center -fill "$color7" \
    -font /usr/share/fonts/TTF/JetBrainsMonoNerdFont-Regular.ttf \
    -pointsize 90 -annotate 0 "ó°¿Ž" "$fallback_poster"
fi

get_poster(){
    if [ -z "$1" ]; then
        echo "Usage: $0 <title> <year (optional)> <type>"
        exit 1
    fi

    type="$1"
    title="$2"
    year="$3"

    # Prepare the title argument for the API request
    encoded_title=$(echo "$title" | tr ' ' '+')

    if [ "$type" == "anime" ]; then
        # Fetch anime data from Jikan API
        response=$(curl -s "https://api.jikan.moe/v4/anime?q=$encoded_title&season=$year")
        poster_url=$(echo "$response" | jq -r '.data[0].images.jpg.large_image_url')
    else
        API_KEY="497fd34e"
        # Fetch movie/show data from OMDB API
        response=$(curl -s "http://www.omdbapi.com/?t=$encoded_title&year=$year&apikey=$API_KEY")
        poster_url=$(echo "$response" | jq -r '.Poster')
    fi

    # Check for errors
    error_message=$(echo "$response" | jq -r '.Error')
    if [ "$error_message" != "null" ]; then
        echo "Error: $error_message"
        poster_url="N/A"
    fi

    if [ "$poster_url" == "N/A" ]; then
        echo "No poster available for '$title', using fallback image."
        cp "$fallback_poster" "$cached/$title.jpg"
    else
        wget -q "$poster_url" -O "$cached/$title.jpg"
        echo "Poster downloaded as '$cached/$title.jpg'"
    fi
}

process_media(){
    media_type="$1"

    case "$media_type" in
        "movies")
            media_directory="$movies_directory"
            category="Movies"
            exec_command="mpv --keep-open=always --write-filename-in-watch-later-config --save-position-on-quit"
            # Find media files directly
            readarray -t lines < <(find -L "$media_directory" -type f \( -iname "*.mp4" -o -iname "*.mkv" \))
            ;;
        "shows" | "anime")
            media_directory="$([ "$media_type" = "shows" ] && echo "$shows_directory" || echo "$anime_directory")"
            category="$([ "$media_type" = "shows" ] && echo "Shows" || echo "Anime")"
            exec_command="$0 --episode"

            # Find directories containing media files
            readarray -t lines < <(find "$media_directory" -mindepth 1 -maxdepth 1 \( -type d -o -type l \) -print0 | while IFS= read -r -d '' dir; do
                if find -L "$dir" -type f \( -iname "*.mp4" -o -iname "*.mkv" \) -print -quit | grep -q .; then
                    echo "$dir"
                fi
            done)
            ;;
        *)
            echo "Invalid media type specified."
            exit 1
            ;;
    esac

    if [ ${#lines[@]} -eq 0 ]; then
        notify-send -r 12 -a rofi-media "rofi-media" "No files were found in $media_directory"
        return
    fi

    for line in "${lines[@]}"; do
        name="${line##*/}"
        name="${name%.*}"

		# Extract the year and remove everything after it
		if [[ "$name" =~ ([1-2][0-9]{3}) ]]; then
		    year="${BASH_REMATCH[1]}"
		    title=$(echo "$name" | sed -e "s/$year.*//" -e 's/[[:punct:]]/ /g' -e 's/[[:space:]]*$//')
		
		    # Check if title is empty or only contains the year
		    if [[ -z "$title" || "$title" =~ ^[[:space:]]*$ ]]; then
		        # If title is empty or only contains spaces, set title to the year itself
		        title="$year"
		    fi
		else
		    year=""
		    title="$(echo "$name" | sed 's/[[:space:]]*$//')"
		fi
	

        if ! [[ -f "$cached/$title.jpg" ]]; then
            get_poster "$media_type" "$title" "$year"
        fi

        desktop_file="$shortcuts/$name.desktop"

        if [[ ! -f "$desktop_file" ]]; then
            cat > "$desktop_file" <<- EOF
            [Desktop Entry]
            Name=$title
            Exec=$exec_command '$line'
            Icon=$cached/$title.jpg
            Type=Application
            Categories=$category;
			EOF
        fi
    done

    rofi -show drun -drun-categories "$category" -theme rofi-media
}

play_media() {
    local file_path="$1"
    local start_position="$2"

	[[ -z "$start_position" ]] && start_position="0"
	
	get_duration &
	
    mpv --quiet --keep-open=always --watch-later-dir="$watchlater_dir" \
        --write-filename-in-watch-later-config --save-position-on-quit \
        --start="$start_position" "$file_path" >/dev/null 2>&1
}

get_duration(){
	sleep 2
	duration="$([[ "$(pgrep mpv)" ]]  && echo '{"command": ["get_property", "duration"]}' | socat - /tmp/mpvsocket | jq -r '.data')"
    printf "%.0f" "$duration" > "$watchlater_dir"/duration
}


save_history(){
	media_history="$cached"/media_history.txt

	local name="${1##*/}"
	
	local duration="$(cat $watchlater_dir/duration)"
	
	file="$(grep -hB1 "start=" $watchlater_dir/* 2>/dev/null | grep -A2 "$name")"

	position="$(echo $file | awk -F= '/start/ {print int($2)}')"
	path="$(echo $file | awk -F' start=' '/^# / {print substr($1, 3)}')"

    local progress=$(($position * 100 / $duration))


	if grep -qw "$name" "$media_history"; then
		sed -i "/$name/d" "$media_history"
	fi

	printf "%s\t%s\t%s\t%s\n" "$name" "$position" "$path" "$progress" >>"$media_history"

	rm "$watchlater_dir"/*
}

check_history(){
	media_history="$cached"/media_history.txt

	local name="${1##*/}"

	position="$(grep -hw "$name" $media_history | awk -F'\t' '{print $2}')"
	path="$(grep -hw "$name" $media_history | awk -F'\t' '{print $3}')"
	progress="$(grep -hw "$name" $media_history | awk -F'\t' '{print $4}')"
	dir="${path%/*}"
	episode=$(echo "${path##*/}" | sed -n -e 's/.*[eE]\([0-9]\{2\}\).*/\1/p' -e 's/.*\b\([0-9]\{2\}\)\b.*/\1/p' | head -n1)
}

prompt(){
	local show="$1"
    check_history "$show"

    local episode_number="$episode"
    local selected_directory="$dir"

    # Check for the next episode in the current season
    next_episode_number=$(printf '%02d' $((10#$episode_number + 1)))
    next_episode_file=$(ls -p "$selected_directory" | grep -v / | sort | grep -E "S[0-9]+E$next_episode_number| - $next_episode_number - | - $next_episode_number\..*|[_\.x-]$next_episode_number\.")

    if [[ -n "$next_episode_file" ]]; then

		options="$(echo -e "Next\nReplay\nSelect\nExit" | rofi -dmenu -mesg "Selecte an option" -theme-str "#mainbox { children: [ message, listview ]; } #textbox { padding: 24px; }")"

		case "$options" in
		"Next")
			play_media "$selected_directory/$next_episode_file"
			save_history "$show"
			episode_number=$(($episode_number + 1))
			prompt "$show"
			;; 
		"Replay")
			play_media "$path"
			save_history "$show"
			prompt "$show"
			;;
		"Select")
			select_episode "$show"
			;;
		"Exit")
			exit 0
			::
		esac

    else
        # Check if there is another season available
        parent_directory="${selected_directory%/*}"
        current_season="${selected_directory##*/}"

        next_season_dir=$(ls -v "$parent_directory" | grep -A1 "$current_season" | tail -n1)

        if [[ -n "$next_season_dir" && "$next_season_dir" != "$current_season" && "$parent_directory" != "$shows_directory" ]]; then
            next_season_dir="$parent_directory/$next_season_dir"
            binge_next_season="$(echo -e "Yes\nNo" | rofi -sort -dmenu -i -width 1500 -p "" -mesg "Next season available. Play next season?" -theme-str "#mainbox { children: [ message, listview ]; } #textbox { padding: 24px; }")"
            if [[ "$binge_next_season" == "Yes" ]]; then
                first_episode_file=$(ls -p "$next_season_dir" | grep -v / | sort | grep -E '\.mp4$|\.mkv$' | head -n1)
                if [[ -n "$first_episode_file" ]]; then
                    play_media "$next_season_dir/$first_episode_file"
                    save_history "$show"
                    prompt "$show"
                fi
            fi
        fi
    fi
}

play_history(){
	local show="$1"
	check_history "$show"

	if [[ "$progress" -gt 90 ]]; then
		
		local episode_number="$episode"
		local selected_directory="$dir"
		
		# Check for the next episode in the current season
	    next_episode_number=$(printf '%02d' $((10#$episode_number + 1)))
	    next_episode_file=$(ls -p "$selected_directory" | grep -v / | sort | grep -E "S[0-9]+E$next_episode_number| - $next_episode_number - | - $next_episode_number\..*|[_\.x-]$next_episode_number\.")
	
	    if [[ -n "$next_episode_file" ]]; then
			echo $next_episode_file
			path="$selected_directory/$next_episode_file"
			position=""
	    else 
			path=""
		fi		
	fi
	
   	[[ -n "$path" ]] && history=$(echo -e "Yes\nNo" | rofi -sort -dmenu -mesg "Resume last episode?" -theme-str "#mainbox { children: [ message, listview ]; } #textbox { padding: 24px; }")

	if [[ "$history" == "Yes" ]]; then
		play_media "$path" "$position"
		save_history "$show"
		prompt "$show"
		exit 0
	else
		select_episode "$show"
	fi
}

select_episode(){
	local show="$1"	
	
    # Define a pattern to match typical season folder names
    season_pattern='(Season[[:space:]]*[0-9]+|S[0-9]+|[0-9]+x[0-9]+|S[0-9]+E[0-9]+|^[0-9]+$|^[0-9]+x[0-9]+)'

    # Check if there are multiple season folders
    season_dirs=$(find -L "$show" -mindepth 1 -maxdepth 1 \( -type d -o -type l \))
    #season_dirs=$(find -L "$show" -mindepth 1 -maxdepth 1 \( -type d -o -type l \) | grep -E "$season_pattern")

    if [[ -n "$season_dirs" ]]; then
        season=$(echo "$season_dirs" | sort | sed 's!.*/!!' | rofi -sort -dmenu -p "Select season:" -mesg "Select the season:")
        [[ -z "$season" ]] && exit 1
        selected_directory="$show/$season"
    else
        selected_directory="$show"
    fi

    # Extract episode numbers and titles, and format the selection
	  selection=$(ls -p "$selected_directory" | grep -v / | grep -E '\.mp4$|\.mkv$' | sort | sed -E '
	    s/.*S[0-9]+[Eex]([0-9]+)[^A-Za-z0-9]*([^0-9]+\S[^0-9]+?)[. ]+[^.]+$/Episode \1: \2/; t;
	    s/.*S[0-9]+[Eex]([0-9]+)[^A-Za-z0-9]*([^0-9]+\S[^0-9]+?)[. ]+.*$/Episode \1: \2/; t;
	    s/.*S[0-9]+[Eex]([0-9]+).*$/Episode \1/; t;
	    s/.* - ([0-9]+) - ([^0-9]+?)\..*$/Episode \1: \2/; t;
	    s/.* - ([0-9]+)\..*$/Episode \1/; t;
	    s/.*S[0-9]+E([0-9]+)\..*$/Episode \1/' | sed -E 's/\./ /g' \
	    | rofi -sort -dmenu -p "Episode: " -mesg "Select the episode:")

    # Map the selected "Episode X: Title" back to the corresponding file name
    if [[ -n "$selection" ]]; then
        episode_number=$(echo "$selection" | grep -o '[0-9]\+')

        # Handle both patterns
		episode_file=$(ls -p "$selected_directory" | grep -E "S[0-9]+E$episode_number| - $episode_number - .*| - $episode_number\..*" | grep -E '\.mp4$|\.mkv$')

        if [[ -n "$episode_file" ]]; then
            play_media "$selected_directory/$episode_file"
			save_history "$show"
            prompt "$show"
        else
            notify-send -a rofi-media "Episode file not found"
        fi  
    fi
}

case "$1" in
    --movies|--shows|--anime)
        process_media "${1#--}" && rm -r "$shortcuts"
        ;;
    --episode)
        play_history "$2"
        ;;
    *)
        echo "Invalid option. Use --movies, --shows, --anime, or --episode."
        ;;
esac
